---
layout: post
title:  "Google Code Jam 2019 Round 1B"
date:   2019-04-29 21:55:30 +0900
categories: ps
---

[GCJ R1B][round]는 새벽 1시에 열려서 잠을 포기하고 참가! 했지만..
컨디션 조절 실패로 (변명) 이번에도 Round 2 진출에 실패하고 말았다.
전체적인 난이도는 [A][proba]가 너무 쉽고, [B][probb]가 생각보다 어려웠으며,
[C][probc]는 구현이 은근히 복잡한 문제였다.

{:toc}
1. toc

## [Manhattan Crepe Cart][proba]

Q×Q(1≤Q≤100,000)그리드 상에 있는 P(1≤P≤500)명의 사람의 현재 위치와 이동 방향이 주어졌을 때,
가장 많은 사람의 진행 방향과 겹치는 점의 위치를 찾는 문제이다.
편의상 각 사람은 하나의 반평면이라고 생각하면 된다:
예를 들어 북쪽을 향하고 있을 경우 $y > y_0$ 인 모든 점이 해당 사람의 진행 방향에 있다고 할 수 있고,
동쪽을 향하고 있을 경우 $x > x_0$ 인 모든 점이 해당 사람의 진행 방향에 있다고 할 수 있다.

풀이는 가로 반평면과 세로 반평면을 따로 고려함으로써 각각 $y$와 $x$좌표를 알아낼 수 있다는 것을 떠올리면 간단하다.
우선 가로 반평면을 해결하는 방법을 살펴보자. 이는 간단한 스윕 라인[^1]을 통해 해결할 수 있다.

북쪽을 바라보는 사람을 이벤트 $(y_0 + 1, +1)$으로 나타낼 수 있고,
같은 방법을 이용해서 남쪽을 바라보는 사람 역시 $(y_0, -1)$으로 나타낼 수 있다.
이제 각 이벤트를 처리하면서 가장 많은 사람의 진행 방향과 겹치는 점을 선택하면 끝!

{% highlight c++ %}
#include<cstdio>
#include<algorithm>
#include<vector>
#define x first
#define y second
#define pb emplace_back
#define ALL(X) (X).begin(),(X).end()
using namespace std;
using ii = pair<int, int>;

int n, m;
vector<ii> p[2];

int sweep(vector<ii>& events, int base) {
    int acnt = base, ret = 0, cnt = base;
    sort(ALL(events));

    for (auto& evt: events) {
        cnt += evt.y;
        if (cnt > acnt) {
            acnt = cnt;
            ret = evt.x;
        }
    }

    return ret;
}

int main()
{
    for (int T, C = scanf("%d", &T); C <= T; ++C) {
        printf("Case #%d: ", C);
        scanf("%d%d", &n, &m);
        p[0].clear();
        p[1].clear();

        int xb = 0, yb = 0;
        for (int i = 0; i < n; i++) {
            int x, y; char d[16];
            scanf("%d%d%s", &x, &y, d);
            if (*d == 'N') {
                p[0].pb(y+1, 1);
            } else if (*d == 'S') {
                ++yb;
                p[0].pb(y, -1);
            } else if (*d == 'E') {
                p[1].pb(x+1, 1);
            } else if (*d == 'W') {
                ++xb;
                p[1].pb(x, -1);
            }
        }

        printf("%d %d\n", sweep(p[1], xb), sweep(p[0], yb));
    }
    return 0;
}
{% endhighlight %}


## [Draupnir][probb]

오딘이 $0$번째 날에 6개의 링을 각각 $r_1, r_2, ..., r_6$개 가지고 있다고 하자($r_i≤100$).
$i$번째 날이 될 때마다, $i\|j$, 즉 $i$의 약수인 $j$번째 링이 두 배로 늘어난다.
따라서 $i$번째 날의 각 링의 개수는 각각 $r_1 \cdot 2^{\lfloor{i/1}\rfloor}, r_2 \cdot 2^{\lfloor{i/2}\rfloor}, ...$개가 된다.
문제는 $r_1, ..., r_6$을 **모르는 상태**에서 $i$번째 날에 오딘이 가지고 있는 모든 링 개수의 합($\mathrm{mod~} 2^{63}$)을 묻는 질문을 통해 $r_1, ..., r_6$을 알아내는 것이다.

풀이의 아이디어는 각 $r_i$가 100보다 작음을 이용, 128진법과 비슷한 아이디어를 통해 합으로부터 각 링의 개수를 분리하는 것이다.
예를 들어 210일 째에 오딘이 가지고 있는 링의 개수를 풀어 쓰면 다음과 같이 표현할 수 있다:
$$
Q(210) = r_1 \cdot 2^{210} + r_2 \cdot 2^{105} + r_3 \cdot 2^{70} + r_4 \cdot 2^{52} + r_5 \cdot 2^{42} + r_6 \cdot 2^{35} \mathrm{~mod~} 2^{63} \\
Q(210) = r_4 \cdot 2^{52} + r_5 \cdot 2^{42} + r_6 \cdot 2^{35}
$$

지수를 살펴보면 각각의 차이가 7보다 크기 때문에 합으로부터 $r_4, r_5, r_6$을 얻어낼 수 있다.

$$
\begin{cases}
r_6 & = & Q(210) \div 2^{35} \mathrm{~mod~} 128 \\
r_5 & = & Q(210) \div 2^{42} \mathrm{~mod~} 128 \\
r_4 & = & Q(210) \div 2^{52} \mathrm{~mod~} 128 \\
\end{cases}
$$

마찬가지로 42일 째의 링 개수는 다음과 같이 표현 가능하다.
$$
Q(42) = r_1 \cdot 2^{42} + r_2 \cdot 2^{21} + r_3 \cdot 2^{14} + r_4 \cdot 2^{10} + r_5 \cdot 2^{8} + r_6 \cdot 2^{7} \\
$$
다행히 이미 $r_4, r_5, r_6$을 알고 있으므로, 아까와 똑같은 방법을 통해 나머지 링의 개수도 구할 수 있다.

$$
\begin{cases}
r_3 & = & (Q(42) - r_4 \cdot 2^{10} - r_5 \cdot 2^{8} - r_6 \cdot 2^{7}) \div 2^{14} \mathrm{~mod~} 128 \\
r_2 & = & (Q(42) - r_4 \cdot 2^{10} - r_5 \cdot 2^{8} - r_6 \cdot 2^{7}) \div 2^{21} \mathrm{~mod~} 128 \\
r_1 & = & (Q(42) - r_4 \cdot 2^{10} - r_5 \cdot 2^{8} - r_6 \cdot 2^{7}) \div 2^{42} \mathrm{~mod~} 128 \\
\end{cases}
$$

{% highlight python %}
def solve3(x, s):
    return [(x >> i) & 127 for i in s]

def solve():
    print(210, flush=True)
    x = solve3(int(input()), [210 // 4, 210 // 5, 210 // 6])

    print(42, flush=True)
    y = int(input()) - sum([x[i] << (42 // (i + 4)) for i in range(3)])

    r = solve3(y, [42 // 1, 42 // 2, 42 // 3]) + x
    print(" ".join([str(x) for x in r]), flush=True)
    if int(input()) == -1: exit(-1)

T, _ = map(int, input().strip().split())
[solve() for C in range(1, T + 1)]
{% endhighlight %}

## [Fair Fight][probc]

이건 졸려서 내일..

{% highlight c++ %}
#include<cstdio>
#include<map>
#include<algorithm>
using namespace std;
using ll = long long;

struct MaxNode {
    using ReturnType = int;
    int v;
    inline MaxNode(ReturnType v=-1e9): v(v) {}
    inline ReturnType Query() const { return v; }
    inline void Update(const ReturnType& x) { v = x; }
    inline MaxNode Combine(const MaxNode& le, const MaxNode& ri) {
        v = max(le.v, ri.v);
        return *this;
    }
};

template<class Node>
struct SegmentTree {
    typedef typename Node::ReturnType T;
    Node *nodes;
    int size;

    inline SegmentTree(int *s, int *e): size(1) {
        int n(e - s);
        while (size <= n || size < 8) size <<= 1;
        nodes = new Node[size<<1];

        for (int i = n; i > 0; i--)
            --e, nodes[i+size].Update(*e);

        for (int i = size - 1; i > 0; i--)
            nodes[i].Combine(nodes[i<<1], nodes[i<<1|1]);
    }

    inline T Query(int l, int r) const {
        Node le, ri, tmp;
        for (l += size, r += size + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) le = tmp.Combine(le, nodes[l++]);
            if (r & 1) ri = tmp.Combine(nodes[--r], ri);
        }
        return tmp.Combine(le, ri).Query();
    }

    inline ~SegmentTree() { delete[] nodes; }
};

const int MAXN = 1e5 + 10;
int n, k, a[MAXN], b[MAXN];

template<typename T>
int searchMaxLeft(T & tree, int l, int r, int i, int x) {
    int ret = 1 << 30;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (tree.Query(min(i, mid), max(i, mid)) <= x) {
            ret = min(ret, mid);
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }

    return ret;
}

template<typename T>
int searchMaxRight(T & tree, int l, int r, int i, int x) {
    int ret = -(1 << 30);
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (tree.Query(min(i, mid), max(i, mid)) <= x) {
            ret = max(ret, mid);
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }

    return ret;
}

int main()
{
    for (int T, C = scanf("%d", &T); C <= T; ++C) {
        scanf("%d%d", &n, &k);

        for (int i = 1; i <= n; i++) scanf("%d", a + i);
        SegmentTree<MaxNode> tree1(a + 1, a + n + 1);

        for (int i = 1; i <= n; i++) scanf("%d", b + i);
        SegmentTree<MaxNode> tree2(b + 1, b + n + 1);

        ll ans = 0;
        map<int, int> ignore;
        for (int i = 1; i <= n; i++) {
            int j = ignore.count(a[i]) ? ignore[a[i]] + 1 : 1;
            int alb = searchMaxLeft(tree1, j, i, i, a[i]);
            int arb = searchMaxRight(tree1, i, n, i, a[i]);

            int lb = max({alb, searchMaxLeft(tree2, j, i, i, a[i] + k)});
            int rb = min({arb, searchMaxRight(tree2, i, n, i, a[i] + k)});
            if (rb >= lb) ans += (rb - i + 1) *1LL* (i - lb + 1);

            int flb = max({alb, searchMaxLeft(tree2, j, i, i, a[i] - k - 1)});
            int frb = min({arb, searchMaxRight(tree2, i, n, i, a[i] - k - 1)});
            if (frb >= flb) ans -= (frb - i + 1) *1LL* (i - flb + 1);

            ignore[a[i]] = i;
        }
        printf("Case #%d: %lld\n", C, ans);
    }
    return 0;
}
{% endhighlight %}


[^1]: [스윕 라인][sweep]에 대한 [탑코더 튜토리얼][tcode], [Baekjoon Online Judge 튜토리얼][cpair]
[round]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706
[proba]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706/000000000012295c
[probb]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706/0000000000122837
[probc]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051706/0000000000122838
[sweep]: https://en.wikipedia.org/wiki/Sweep_line_algorithm
[tcode]: https://www.topcoder.com/community/competitive-programming/tutorials/line-sweep-algorithms/
[cpair]: https://www.acmicpc.net/blog/view/25
