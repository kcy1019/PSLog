---
layout: post
title:  "Google Code Jam 2019 Qualification Round"
date:   2019-04-07 11:33:30 +0900
categories: ps
---

이번 [GCJ 퀄 라운드][qual]는 간단한 아이디어로 풀리는 문제가 많아서 재미있었다.
물론 C번은 런타임 에러가 발생할 수 있는 함정이 여럿 있어서 약간은 악랄해 보인 것과,
큰 수 나눗셈 계산이 필요해서 언어 선택에 조금의 제한이 생기기는 했지만.

<style type="text/css">
    #markdown-toc { list-style-type: upper-alpha; }
    #markdown-toc  ol { list-style-type: circle; }
</style>

{:toc}
1. toc

## [Foregone Solution][proba]

4가 한 개 이상 포함된 숫자 N을, 4를 포함하지 않는 두 양의 정수 X와 Y의 합으로 나타내는 문제,
즉 `str(X).count('4') == 0 and str(Y).count('4') == 0 and X + Y == N`인 X, Y를 아무거나 찾으면 된다.
따라서 풀이는 그냥 4가 나타나는 자리에만 2가 들어가도록 하면 끝!

{% highlight python %}
T = int(input().strip()) + 1
for C in range(1, T):
    x = input().strip()
    a = x.replace('4', '2')
    x = int(x) - int(a)
    print("Case #{}: {} {}".format(C, x, a))
{% endhighlight %}

## [You Can Go Your Own Way][probb]

N by N 격자에서 오른쪽과 아래 쪽의 이동만 이용해서 왼쪽 위의 점부터 오른쪽 아래 점으로 이동하는 경로를 출력하는 문제이다.
다만, 하나의 경로가 주어지고, 이 경로와 겹치는 이동이 있어서는 안 된다.
이 문제의 풀이 역시도 정말 간단한데, 두 개의 이동 방법으로 끝 점까지 이동하기 위해서는 N-1 번의 아래 이동과 N-1번의 오른쪽 이동이 필요하다는 것을 이용해서, 주어진 이동 경로의 오른쪽과 아래 이동을 서로 바꾸면 항상 90도 회전한 경로로 이동하므로 겹치지 않고 이동할 수 있다.


{% highlight python %}
T = int(input().strip()) + 1
for C in range(1, T):
    _, x = input(), input().strip()
    a = x.replace('E','s').replace('S','E').replace('s','S')
    print("Case #{}: {}".format(C, a))
{% endhighlight %}

## [Cryptopangrams][probc]

N 이하의 소수 중에서 26개를 뽑아 크기 순서대로 각 소수에 A, B, ..., Z 를 대응시켰을 때,
알파벳 대문자로 이루어진 팬그램[^1] 문자열을 연속된 두 문자에 대응하는 소수의 곱으로 암호화 한 결과가 주어진다.
N과 암호화된 정수의 리스트를 가지고 복호화 하는 문제이다.

팬그램이기 때문에 풀이는 매우매우 간단하게 떠오르지만, 이번 라운드에서 가장 많은 함정을 가지고 있는 문제가 아니었을까 싶다.

```
ABCDEFGHIJKLMNOPQRSTUVWXYZ
6 15 35 77 143 221 323 437 667 899 1147 1517 1763 2021 2491 3127 3599 4087 4757 5183 5767 6557 7387 8633 9797
```

첫 문자와 마지막 문자를 제외한 모든 문자는 암호문에서 두 번 등장하는 사실을 알 수 있다. 예를 들어 B는 6과 15에 모두 등장하므로, `gcd(6, 15)` 를 이용해 B에 해당하는 소수가 3임을 알 수 있다.
같은 방법을 반복해서 모든 소수를 얻으면 끝!

### 함정: 팰린드롬

A와 B를 너무 쉽게 풀어서, 이것도 간단하겠지~ 하면서 막 내다가, 부끄럽게도.. 결국 테스트 데이터 생성기를 짜고 나서야 이 함정을 깨달았다.

```
ABACDEFGHIJKLMNOPQRSTUVWXYZ
6 6 10 35 77 143 221 323 437 667 899 1147 1517 1763 2021 2491 3127 3599 4087 4757 5183 5767 6557 7387 8633 9797
```

실제로는 이렇게 암호문에 같은 수가 등장하는 경우도 고려해주어야 한다. (`ABA => 6 6`)

{% highlight python %}
from fractions import gcd
def uniq(x): return sorted(list(set(filter(lambda y: y != 1, x))))
alphabet = [x for x in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ']

def decrypt(d, c, s):
    a = [s]
    for i in range(n-1): a.append(c[i] // a[-1])
    return "".join([d[u] for u in (a + [c[-1] // a[-1]])])

T = int(input().strip()) + 1
for C in range(1, T):
    _, n = map(lambda x: int(x.strip()), input().split())
    x = list(map(lambda x: int(x.strip()), input().split()))

    g = uniq(sum([[gcd(a, b) for b in x if gcd(a, b) > 1 and a != b] for a in x], []))
    g = uniq(sum([[a // b for b in g if a % b == 0] for a in x], g))
    d = {p: q for q, p in zip(alphabet, g)}

    for p in filter(lambda p: x[0] % p == 0, g):
        try:
            print("Case #{}: {}".format(C, decrypt(d, x, p)))
            break
        except: pass
{% endhighlight %}


## [Dat Bae][probd]

정해와는 조금 다르게, BFS와 비슷한 방법으로 해결했다.
간단하게 스몰(Test Set 1) 문제를 다음과 같은 트리 형태로 나타내어 보자.

<img src="/images/datbae.png" style="max-width:350px">

노드의 개수가 최대 1024개이므로, 트리의 높이는 10이 되고,
각 높이 별로 쿼리를 한 번씩 하면 어느 칸이 고장인지 간단히 알 수 있다.
각각의 노드에서 구간을 두 개로 쪼갤 때,
왼쪽 절반에는 `1`, 오른쪽 절반에는 `0`을 부여하면
쿼리 결과의 1과 0의 개수를 세어 각 구간에 고장난 머신이 몇 개 존재하는지 알 수 있다.

{% highlight python %}
from sys import stdout

def send(q):
    print("".join([str(x) for x in q]), flush=True)
    res = input().strip()
    if len(res) == 2 and res == "-1": exit(-1)
    return res

def solve(n, b, f, p=0):
    q, ans, qcnt = [[p, n, b, True]], [], 0
    while len(q) > 0 and qcnt <= f:
        query, nq = [0] * n, []
        stop = True
        for rng in q:
            p, ln, b, use = rng
            if b == 0 or ln == 0: continue

            if b == ln:
                nq.append([p, ln, b, False])
                if use:
                    ans += [p + x for x in range(ln)]
                continue

            m = ln // 2
            for i in range(m): query[p+i] = 1
            for i in range(ln-m): query[p+m+i] = 0
            nq += [[p, m, 0, True], [p + m, ln - m, 0, True]]
            stop = False

        if stop or qcnt >= f: break
        res = send(query)
        qcnt += 1

        faults, nptr = 0, 0
        for i in range(len(q)):
            p, ln, b, _ = q[i]
            if b == 0 or ln == 0: continue

            if b == ln:
                nptr, faults = nptr + 1, faults + b
                continue

            r = res[p - faults:p - faults + ln - b]
            m, v = ln // 2, sum([int(x) for x in r])
            nq[nptr+0][-2], nq[nptr+1][-2] = m - v, b - (m - v)
            nptr, faults = nptr + 2, faults + b
        q = nq

    return " ".join([str(x) for x in sorted(ans)])


T = int(input().strip())
for C in range(1, T + 1):
    n, b, f = map(lambda x: int(x.strip()), input().split())
    w = solve(n, b, f)
    print(w, flush=True)
    if int(input().strip()) == -1: exit(-2)

exit(0)
{% endhighlight %}

Test Set 2 (`F = 5`) 일 때에는 어떻게 하면 될까?
기존과 같이 트리의 각 레벨 별로 한 번씩 쿼리를 하되,
가능할 경우 구간을 2개보다 잘게 나누어서 높이를 줄이면 된다.

중요한 아이디어는, 구간을 쪼갰을 때 아무리 많이 고장나도 구간 하나가 통째로 지워지지 않을 만큼만 쪼개면 (`(length - 1) // broken`) 기존과 같이 쉽게 처리할 수 있다는 것이다.

{% highlight python %}
from sys import stdout

def send(q):
    print("".join([str(x) for x in q]), flush=True)
    stdout.flush()
    res = input().strip()
    if len(res) == 2 and res == "-1": exit(-1)
    return res


def solve(n, b, f, p=0):
    q, ans, qcnt = [[p, n, b, True]], [], 0
    while len(q) > 0 and qcnt <= f:
        query, nq = [0] * n, []
        stop = True
        for rng in q:
            p, ln, b, use = rng
            if b == 0 or ln == 0: continue

            if b == ln:
                nq.append([p, ln, b, False])
                if use:
                    ans += [p + x for x in range(ln)]
                continue

            stop = False

            if 3 < (ln-1) // b:
                k = (ln-1) // b
                pp, m = p, ln // k

                for j in range(k-1):
                    for i in range(m): query[pp+i] = (j + 1) % 2
                    nq.append([pp, m, 0, True])
                    pp += m

                for i in range(ln - m * (k-1)): query[pp+i] = k % 2
                nq.append([pp, ln - m * (k-1), 0, True])
                continue


            pp, m = p, ln // 2
            for i in range(m): query[pp+i] = 1
            nq.append([pp, m, 0, True])

            pp += m
            for i in range(ln - m): query[pp+i] = 0
            nq.append([pp, ln - m, 0, True])


        if stop or qcnt >= f: break
        res = send(query)
        qcnt += 1

        faults, nptr = 0, 0
        for i in range(len(q)):
            p, ln, b, _ = q[i]
            if b == 0 or ln == 0: continue

            if b == ln:
                nptr, faults = nptr + 1, faults + b
                continue

            r = res[p - faults:p - faults + ln - b]

            if 3 < (ln-1) // b:
                k = (ln-1) // b
                anti = "%d" % (1 - k % 2)
                if r[-1] == anti: r = r[:r.rfind(anti)]
                pp, m = 0, ln // k

                for j in range(k-1):
                    u = r[pp:pp+m]
                    if int(u[-1]) != (j + 1) % 2: u = u[:u.rfind(str(1 - (j + 1) % 2))]
                    fv = m - sum([(j + 1) % 2 == int(x) for x in u])
                    nq[nptr][-2] = fv
                    nptr, faults = nptr + 1, faults + fv
                    pp += m - fv

                u = r[pp:pp+ln-m*(k-1)]
                if int(u[-1]) != k % 2: u = u[:u.rfind(str(1 - k % 2))]
                fv = (ln - m * (k - 1)) - sum([k % 2 == int(x) for x in u])
                nq[nptr][-2] = fv
                nptr, faults = nptr + 1, faults + fv
                continue

            m, v = ln // 2, sum([int(x) for x in r])
            nq[nptr+0][-2], nq[nptr+1][-2] = m - v, b - (m - v)
            nptr, faults = nptr + 2, faults + b

        q = nq

    return " ".join([str(x) for x in sorted(ans)])


T = int(input().strip())
for C in range(1, T + 1):
    n, b, f = map(lambda x: int(x.strip()), input().split())
    w = solve(n, b, f)
    print(w, flush=True)
    if int(input().strip()) == -1: exit(-2)

exit(0)
{% endhighlight %}

사실 이건 문제의 난이도 보다는 인터랙티브 문제라 테스트가 매끄럽지 않아서 조금 힘들었다.


[^1]: [Pangram][pangram]: 모든 알파벳이 한 번 이상 등장하는 문자열

[qual]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705
[proba]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231
[probb]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da
[probc]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b
[probd]: https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de
[pangram]: https://en.wikipedia.org/wiki/Pangram
